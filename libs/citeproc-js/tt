11c11
< from makejson import jsonwalker
---
> from ConfigParser import ConfigParser
44,64d43
< def path(name):
<     if name == "std":
<         return os.path.join("tests", "fixtures", "std", "processor-tests", "humans")
<     elif name == "styles":
<         return os.path.join("tests", "fixtures", "std", "styles")
<     elif name == "run":
<         return os.path.join("tests", "fixtures", "run")
<     elif name == "bundled":
<         return os.path.join("tests", "bundled")
<     elif name == "styletests":
<         return os.path.join("tests", "styletests")
<     elif name == "local":
<         return os.path.join("tests", "fixtures", "local")
<     elif name == "config":
<         return os.path.join("tests", "config")
<     elif name == "citeproc-js":
<         return os.path.join("tests", "citeproc-js")
<     elif name == "runners":
<         return os.path.join("tests", "runners")
<     elif name == "demo":
<         return os.path.join("demo")
78,79c57,58
<         for p in [".", "src", path("std"), path("local"), path("bundled"), path("styletests"), path("citeproc-js"), path("demo")]:
<             for file in os.listdir(p):
---
>         for path in [".", "src", os.path.join("tests", "std"), os.path.join("tests","std","humans"),os.path.join("tests","std","bundled"), os.path.join("tests","std","machines"),os.path.join("tests","citeproc-js")]:
>             for file in os.listdir( path ):
82,94c61
<                 if file.endswith(".src"):
<                     continue
<                 if file.endswith(".sh"):
<                     continue
<                 if file.endswith(".csl"):
<                     continue
<                 if file.endswith(".py"):
<                     continue
<                 if file.endswith(".html"):
<                     continue
<                 if file.endswith(".css"):
<                     continue
<                 self.process_file(p,file)
---
>                 self.process_file(path,file)
96,97c63,64
<     def process_file(self,p,file):
<         filepath = os.path.join(p, file)
---
>     def process_file(self,path,file):
>         filepath = os.path.join( path, file)
99c66
<         text = fixEndings(open(filepath, "rb").read())
---
>         text = fixEndings(open(filepath).read())
107,172c74
<             open(filepath,"w+b").write(text)
< 
< class Bundle:
<     
<     def __init__(self, mode=None):
<         if mode == "zotero":
<             self.citeproc = "citeproc_zotero.js"
<         else:
<             self.citeproc = "citeproc.js"
<         self.mode = mode
<         f = ["load"]
<         if mode == "zotero":
<             f.extend(["print_zotero", "xmldom"])
<         else:
<             f.extend(["print"])
<         f.extend(["system","sort","util_disambig","util_nodes","util_dateparser","build"]);
<         f.extend(["util_static_locator","util_processor","util_citationlabel","api_control"]);
<         f.extend(["queue","state","api_cite","api_bibliography","util_integration","api_update"]);
<         f.extend(["util_locale","node_bibliography","node_choose","node_citation","node_comment"]);
<         f.extend(["node_date","node_datepart","node_elseif","node_else","node_etal","node_group"]);
<         f.extend(["node_if","node_conditions","node_condition","util_conditions","node_info"]);
<         f.extend(["node_institution","node_institutionpart","node_key"]);
<         f.extend(["node_label","node_layout","node_macro","util_names_output","util_names_tests"]);
<         f.extend(["util_names_truncate","util_names_divide","util_names_join","util_names_common"]);
<         f.extend(["util_names_constraints","util_names_disambig","util_names_etalconfig","util_names_etal"]);
<         f.extend(["util_names_render","util_publishers","util_label","node_name","node_namepart"]);
<         f.extend(["node_names","node_number","node_sort","node_substitute","node_text","attributes"]);
<         f.extend(["stack","util_parallel","util","util_transform","obj_token","obj_ambigconfig"]);
<         f.extend(["obj_blob","obj_number","util_datenode","util_date","util_names","util_dates"]);
<         f.extend(["util_sort","util_substitute","util_number","util_page","util_flipflop"]);
<         f.extend(["formatters","formats","registry","disambig_names","disambig_citations"]);
<         f.extend(["disambig_cites"]);
<         self.files = f
<     
<     def deleteOldBundle(self):
<         if os.path.exists( self.citeproc ):
<             os.unlink(self.citeproc)
< 
<     def cleanFile(self, subfile):
<         subfile = fixEndings(subfile)
<         subfile = re.sub("(?m)^(\/\*.*?\*\/)$", "", subfile)
<         subfile = re.sub("(?sm)^\s*\/\*.*?^\s*\*\/","",subfile)
<         subfile = re.sub("(?sm)^\s*//SNIP-START.*?^\s*//SNIP-END","",subfile)
<         subfile = re.sub("(?sm)^\s*//.*?$","",subfile)
<         subfile = re.sub("(?sm)^\s*load.*?$","",subfile)
<         subfile = re.sub("(?sm)^\s*\n","",subfile)
<         return subfile
< 
<     def createNewBundle(self):
<         file = ""
<         for f in self.files:
<             filename = os.path.join( "src", "%s.js"%f)
<             ifh = open(filename, "rb")
<             file += self.cleanFile(ifh.read())
<         open(self.citeproc,"w+b").write(file)
<         if self.mode == "zotero":
<             print "Wrote bundle code with e4x support and Zotero error handling to ./citeproc_zotero.js "
<         if self.mode == None:
<             open(os.path.join("demo", self.citeproc),"w+b").write(file)
< 
<             for f in ["xmle4x", "xmldom"]:
<                 filename = os.path.join( "src", "%s.js" % f)
<                 ifh = open(filename, "rb")
<                 file = self.cleanFile(ifh.read())
<                 open("%s.js" % f, "w+b").write(file)
<                 open(os.path.join("demo", "%s.js" % f), "w+b").write(file)
---
>             open(filepath,"w+").write(text)
175c77
<     def __init__(self,opt,args,category,force=None):
---
>     def __init__(self,opt,args,force=None):
181d82
<         self.category = category
182a84
>         self.tests = os.path.join(os.getcwd(), "processor-tests")
189,191d90
<         self.tests = os.path.join( os.getcwd(), "tests")
<         self.runners = os.path.join( self.tests, "runners")
<         self.makedirs()
193,203d91
<         self.copySource()
< 
<     def makedirs(self):
<         for dir in ("std", "citeproc-js", "runners"):
<             p = path(dir)
<             if not os.path.exists(p):
<                 os.makedirs(p)
<         for subdir in ("humans","machines"):
<             p = os.path.join(path("run"), subdir)
<             if not os.path.exists(p):
<                 os.makedirs(p)
206,207d93
<         return (path("run"),)
<         ## The stuff below is irrelevant
209,210c95
<             print "one"
<             return (path(self.force),)
---
>             return ( os.path.join( self.tests, self.force), )
212,213c97
<             print "two"
<             return (path("run"),)
---
>             return (os.path.join(self.tests),)
216,227c100,108
<         if self.opt.processor:
<             print "opt.processor is WIP"
<         else:
<             if len(self.args) == 2:
<                 filename = "%s_%s.txt" % tuple(self.args)
<                 filepath = None
<                 for path in self.path():
<                     if os.path.exists( os.path.join(path, "humans", filename)):
<                         filepath = (path,os.path.join("humans", filename))
<                         break
<                 if not filepath:
<                     raise MissingHumansFile(filename,[os.path.join(p,"humans") for p in self.path()])
---
>         if len(self.args) == 2:
>             filename = "%s_%s.txt" % tuple(self.args)
>             filepath = None
>             for path in self.path():
>                 if os.path.exists( os.path.join(path, "humans", filename)):
>                     filepath = (path,os.path.join("humans", filename))
>                     break
>             if not filepath:
>                 raise MissingHumansFile(filename,[os.path.join(p,"humans") for p in self.path()])
229,241c110,117
<             else:
<                 for path in self.path():
<                     filenames = os.listdir(os.path.join(path,"humans"))
<                     filenames.sort()
<                     for filename in filenames:
<                         # citeproc-js can only reconcile one level of flip-floppery
<                         #if filename == "decorations_NestedQuotesInnerReverse.txt":
<                         #    continue
<                         if not filename.endswith(".txt"): continue
<                         if args:
<                             if not filename.startswith("%s_" % self.args[0]): continue
<                         if not self.files['humans'].has_key(filename):
<                             self.files['humans'][filename] = (path,os.path.join("humans",filename))
---
>         else:
>             for path in self.path():
>                 for filename in os.listdir(os.path.join(path,"humans")):
>                     if not filename.endswith(".txt"): continue
>                     if args:
>                         if not filename.startswith("%s_" % self.args[0]): continue
>                     if not self.files['humans'].has_key(filename):
>                         self.files['humans'][filename] = (path,os.path.join("humans",filename))
244,245c120,122
<         for subdir in ["run"]:
<             for file in os.listdir(os.path.join(path(subdir), "machines")):
---
>         for path in self.path():
>             mstd = os.path.join(path, "machines")
>             for file in os.listdir(mstd):
247c124
<                 os.unlink(os.path.join(path(subdir), "machines", file))
---
>                 os.unlink(os.path.join(mstd, file))
253,255c130,132
<             mpath = os.path.join(self.files['humans'][filename][0], "machines", "%s.json" % filename[:-4] )
<             hp = os.path.sep.join(hpath)
<             mp = os.path.join(mpath)
---
>             mpath = os.path.join( self.files['humans'][filename][0], "machines", "%s.json" % filename[:-4] )
>             hp = os.path.sep.join( hpath )
>             mp = os.path.join( mpath )
258c135
<             if not os.path.exists(mp):
---
>             if not os.path.exists( mp ):
268,347c145,152
<             if not self.opt.processor:
<                 m = re.match("([-a-z]*)_.*",filename)
<                 if m:
<                     groupkey = m.group(1)
<                     if not groups.has_key(groupkey):
<                         groups[groupkey] = {"mtime":0,"tests":[]}
<                     groups[groupkey]["tests"].append(filename)
<                     if hmod > groups[groupkey]["mtime"]:
<                         groups[groupkey]["mtime"] = mmod
<         if len(self.args) < 2:
<             for group in groups.keys():
<                 if self.opt.teststyles:
<                     gp = os.path.join(path("styletests"), "%s.js"%group)
<                 else:
<                     gp = os.path.join(path("bundled"), "%s.js"%group)
<                 needs_gp = True
<                 if os.path.exists( gp ):
<                     needs_gp = False
<                     gt = os.stat(gp)[ST_MTIME]
<                 # if force or needs_gp or groups[group]["mtime"] > gt:
<                 if needs_gp or groups[group]["mtime"] > gt:
<                     if self.opt.verbose:
<                         sys.stdout.write("!")
<                     if self.opt.teststyles:
<                         ofh = open( os.path.join(path("styletests"), "%s.js" % group), "w+b" )
<                     else:
<                         ofh = open( os.path.join(path("bundled"), "%s.js" % group), "w+b" )
<                     group_text = '''dojo.provide("%s.%s");
< doh.register("%s.%s", [
< ''' % (self.category,group,self.category,group)
<                     ofh.write(group_text)
<                     for filename in [x[:-4] for x in groups[group]["tests"]]:
<                         if self.opt.verbose:
<                             sys.stdout.write("+")
<                         entry_text = '''    function(){
<         var test = new StdRhinoTest("%s");
<         doh.assertEqual(test.result, test.run());
<     }, 
< ''' % filename
<                         ofh.write(entry_text)
<                     ofh.write("]);\n")
< 
<     def buildRunner(self):
<         has_files = False
<         ofh = open( os.path.join(path("runners"), "run.js"), "w+b")
<         header = 'dojo.require("doh.runner");\n'
<         ofh.write(header)
<         if self.opt.processor:
<             testpath = path("citeproc-js")
<             self.category = "citeproc_js"
<         elif self.opt.teststyles:
<             testpath = path("styletests")
<             self.category = "styletests"
<         else:
<             testpath = path("bundled")
<             self.category = "std"
<         if len(args) == 2:
<             keys = self.files['humans'].keys()
<             if len(keys):
<                 file = keys[0]
<                 set = os.path.split( self.files['humans'][file][0] )[-1]
<                 body = '''doh.register("%s.%s", [
<     function(){
<         var test = new StdRhinoTest("%s","%s");
<         doh.assertEqual(test.result, test.run());
<     },
< ])
< ''' % (set,file[:-4],file[:-4],set)
<                 ofh.write(body)
<                 has_files = True
<         else:
<             count = 0
<             for file in [x for x in os.listdir(testpath)]:
<                 if not file.endswith('.js'): continue
<                 if len(self.args) and not file.startswith('%s.'%args[0]): continue
<                 has_files = True
<                 ofh.write('dojo.require("%s.%s");\n' % (self.category,file[:-3]))
<         ofh.write("tests.run();")
<         if not has_files:
<             raise NoFilesError
---
>             m = re.match("([a-z]*)_.*",filename)
>             if m:
>                 groupkey = m.group(1)
>                 if not groups.has_key(groupkey):
>                     groups[groupkey] = {"mtime":0,"tests":[]}
>                 groups[groupkey]["tests"].append(filename)
>                 if hmod > groups[groupkey]["mtime"]:
>                     groups[groupkey]["mtime"] = mmod
352c157
<         test = CslTest(opt,hpath,filename)
---
>         test = CslTest(opt,self.cp,hpath,filename)
357,382d161
<     def runTests(self,bundle=False):
<         cp = ConfigParser()
<         cp.read(os.path.join(path("config"), "test.cnf"))
<         if self.opt.tracemonkey:
<             
<             engine = cp.get("tracemonkey","command")
<             nick = "tracemonkey"
<         elif self.opt.rhino_json:
<             engine = cp.get("rhino","command")
<             nick = "rhino-json"
<         else:
<             engine = cp.get("rhino","command")
<             nick = "rhino"
<         bundleext = ""
<         if bundle:
<             bundleext = "-bundled"
<         runpath = os.path.join(path("runners"), "%s%s.js" %(nick,bundleext))
< 
<         command = "%s %s" % (engine,runpath)
<         ifh = sub.Popen(command,shell=True, stdout=sub.PIPE).stdout
<         while 1:
<             line = ifh.readline()
<             if not line: break
<             line = fixEndings(line)
<             sys.stdout.write(line)
< 
385,386c164,165
<         if os.path.exists(self.pickle):
<             upfh = open(self.pickle, "rb")
---
>         if os.path.exists( self.pickle ):
>             upfh = open(self.pickle)
398c177
<             test = CslTest(opt,p,filename,pos=pos)
---
>             test = CslTest(opt,self.cp,p,filename,pos=pos)
406,425c185,195
<         if not os.path.exists(path("bundled")):
<             os.makedirs(path("bundled"))
< 
<         if not os.path.exists(path("styletests")):
<             os.makedirs(path("styletests"))
< 
<         if not os.path.exists(path("std")):
<             os.makedirs(path("std"))
< 
<         if not os.path.exists(os.path.join(path("run"))):
<             os.makedirs(path("run"))
< 
<         if not os.path.exists(os.path.join(os.path.join(path("run"), "machines"))):
<             os.makedirs(os.path.join(path("run"), "machines"))
< 
<         if not os.path.exists(os.path.join(os.path.join(path("run"), "humans"))):
<             os.makedirs(os.path.join(path("run"), "humans"))
< 
<         if not os.path.exists(path("config")):
<             os.makedirs(path("config"))
---
>         for path in self.path():
>             if not os.path.exists(os.path.join(path, "machines")):
>                 os.makedirs(os.path.join(path, "machines"))
> 
>         if not os.path.exists( os.path.join("config") ):
>             os.makedirs( os.path.join("config") )
> 
>         if not os.path.exists( os.path.join("config", "processor.cnf") ):
>             test_template = '''[jing]
> command: java -jar
> path: ../jing/bin/jing.jar
427,432c197,198
<         if not os.path.exists(os.path.join(path("config"), "test.cnf")):
<             test_template = '''[tracemonkey]
< command: /home/bennett/src/jslibs/Linux_32_opt/jshost -u
< 
< [rhino]
< command: java -client -jar ./rhino/js-1.7R3.jar -opt 8
---
> [csl]
> v1.0: ../citeproc-js/csl/1.0/csl.rnc
434c200
<             ofh = open(os.path.join(path("config"), "test.cnf"), "w+b" )
---
>             ofh = open( os.path.join("config", "processor.cnf"), "w+" )
437,465c203,204
< 
<     def copySource(self):
<         for filename in os.listdir(os.path.join(path("run"), "humans")):
<             os.unlink(os.path.join(path("run"), "humans", filename))
<         if self.opt.teststyles:
<             sourcedirs = []
<             cp = ConfigParser()
<             cp.read(os.path.join(path("config"), "test.cnf"))
<             styletesttopdir = cp.get("style", "testdirs")
<             if os.path.exists(styletesttopdir):
<                 for subdir in os.listdir(styletesttopdir):
<                     fullpath = os.path.join(styletesttopdir, subdir)
<                     if not os.path.isdir(fullpath) or subdir == ".git":
<                         continue
<                     sourcedirs.append(fullpath)
<         else:
<             sourcedirs = [path("local"), path("std")]
<         for sourcedir in sourcedirs:
<             filenames = os.listdir(sourcedir)
<             filenames.sort()
<             for filename in filenames:
<                 if not filename.endswith(".txt"):
<                     continue
<                 filepath = os.path.join(path("run"), "humans", filename)
<                 if os.path.exists(filepath):
<                     print "WARNING: duplicate fixture name \"%s\"" % filename
<                 ofh = open(filepath, "w+b")
<                 ofh.write(open(os.path.join(sourcedir, filename), "rb").read())
<                 ofh.close()
---
>         self.cp = ConfigParser()
>         self.cp.read(os.path.join("config", "processor.cnf"))
468c207
<     def __init__(self,opt,hpath,testname,pos=0):
---
>     def __init__(self,opt,cp,hpath,testname,pos=0):
469a209
>         self.cp = cp
473c213
<         self.hp = os.path.sep.join(hpath)
---
>         self.hp = os.path.sep.join( hpath )
476,477c216,217
<         self.RE_ELEMENT = '(?sm)^(.*>>=.*%s[^\n]+)\n(.*)(\n<<=.*%s.*)'
<         self.RE_FILENAME = '^[-a-z]+_[a-zA-Z0-9]+\.txt$'
---
>         self.RE_ELEMENT = '(?sm)^(.*>>=.*%s[^\n]+)(.*)(\n<<=.*%s.*)'
>         self.RE_FILENAME = '^[a-z]+_[a-zA-Z0-9]+\.txt$'
481c221
<         self.raw = fixEndings(unicode(open(os.path.sep.join(hpath), "rb").read()))
---
>         self.raw = fixEndings(open( os.path.sep.join(hpath)).read())
484d223
<         ## print "kkk: %s" % (self.testname,)
488,502c227,228
<                 if self.opt.teststyles:
<                     cp = ConfigParser()
<                     cp.read(os.path.join(path("config"), "test.cnf"))
<                     stylesdir = cp.get("style", "styles")
<                     stylepath = os.path.join(stylesdir, self.data['csl'])
<                 else:
<                     stylepath = os.path.join(os.path.join(path("styles")), self.data['csl'])
<                 self.data['csl'] = fixEndings(open(stylepath, "rb").read())
<             if element == "CSL" and self.opt.rhino_json:
<                 w = jsonwalker()
<                 doc = w.makedoc(self.data['csl'])
<                 self.data['csl'] = w.walktojson(doc)
<                 #print self.data['csl']
< 
<         self.extract("RESULT",required=True,is_json=False,rstrip=True)
---
>                 self.data['csl'] = fixEndings(open( os.path.join("styles", self.data['csl'])).read())
>         self.extract("RESULT",required=True,is_json=False)
509,512d234
<         self.extract("OPTIONS",required=False,is_json=True)
<         self.extract("MULTIAFFIX",required=False,is_json=True)
<         self.extract("LANGPARAMS",required=False,is_json=True)
<         self.extract("INPUT2",required=False,is_json=True)
536,551d257
<         if self.data["options"]:
<             options_str = json.dumps(self.data["options"],indent=4,sort_keys=True,ensure_ascii=False)
<             m = re.match(self.RE_ELEMENT % ("OPTIONS", "OPTIONS"),self.raw)
<             newraw = m.group(1) + "\n" + options_str + m.group(3)
<         if self.data["multiaffix"]:
<             multiaffix_str = json.dumps(self.data["multiaffix"],indent=4,sort_keys=True,ensure_ascii=False)
<             m = re.match(self.RE_ELEMENT % ("MULTIAFFIX", "MULTIAFFIX"),self.raw)
<             newraw = m.group(1) + "\n" + multiaffix_str + m.group(3)
<         if self.data["langparams"]:
<             langparams_str = json.dumps(self.data["langparams"],indent=4,sort_keys=True,ensure_ascii=False)
<             m = re.match(self.RE_ELEMENT % ("LANGPARAMS", "LANGPARAMS"),self.raw)
<             newraw = m.group(1) + "\n" + langparams_str + m.group(3)
<         if self.data["input2"]:
<             input2_str = json.dumps(self.data["input2"],indent=4,sort_keys=True,ensure_ascii=False)
<             m = re.match(self.RE_ELEMENT % ("INPUT2", "INPUT2"),self.raw)
<             newraw = m.group(1) + "\n" + input2_str + m.group(3)
565c271
<             open(self.hp,"w+b").write(newraw)
---
>             open(self.hp,"w+").write(newraw)
594,596c300,301
<         s = json.dumps(self.data, indent=4, sort_keys=True, ensure_ascii=False )
<         s = s.replace(u"\u200b", "\\u200b")
<         open(mpath,"w+b").write(s)
---
>         json.dump(self.data, open(mpath,"w+"), indent=4, sort_keys=True, ensure_ascii=False )
> 
600,602c305,307
<         if not os.path.exists(os.path.join("..","jing")):
<             print "Error: jing not found as sibling of processor archive."
<             print "  Looked in: %s" % os.path.join("..","jing")
---
>         if not os.path.exists(self.cp.get("jing", "path")):
>             print "Error: jing not found."
>             print "  Looked in: %s" % self.cp.get("jing", "path")
606c311
<             rnc_path = os.path.join("csl","%s" % m.group(1), "csl.rnc")
---
>             rnc_path = os.path.join(self.cp.get("csl", "v%s" % m.group(1)))
614c319
<         jfh = os.popen("java -jar %s -c %s %s" % (os.path.join("..","jing","bin","jing.jar"),rnc_path,tfilename))
---
>         jfh = os.popen("%s %s -c %s %s" % (self.cp.get("jing", "command"), self.cp.get("jing", "path"),rnc_path,tfilename))
648c353
<             pfh = open( self.pickle,"w+b")
---
>             pfh = open( self.pickle,"w+")
662c367
<     usage = '\n%prog [options] [<group> [testname]]\n%prog -p [options] [testname]'
---
>     usage = '\n   %prog [options]'
667,674d371
<     parser.add_option("-T", "--tracemonkey", dest="tracemonkey",
<                       default=False,
<                       action="store_true", 
<                       help='Use the tracemonkey JS engine, rather than the Rhino default.')
<     parser.add_option("-J", "--rhino-json", dest="rhino_json",
<                       default=False,
<                       action="store_true", 
<                       help='Use the rhino JS engine with JSON input.')
683,698d379
<     parser.add_option("-s", "--standard", dest="testrun",
<                       default=False,
<                       action="store_true", 
<                       help='Run tests.')
<     parser.add_option("-S", "--styles", dest="teststyles",
<                       default=False,
<                       action="store_true", 
<                       help='Run style tests only.')
<     parser.add_option("-r", "--release", dest="bundle",
<                       default=False,
<                       action="store_true", 
<                       help='Bundle processor, apply license to files, and test with bundled code.')
<     parser.add_option("-p", "--processor", dest="processor",
<                       default=False,
<                       action="store_true", 
<                       help='Run processor tests (cannot be used with -c, -g or -s opts, takes only test name as single argument).')
703,710d383
<     parser.add_option("-B", "--bundle-only", dest="makebundle",
<                       default=False,
<                       action="store_true", 
<                       help='Create the citeproc.js bundle and exit.')
<     parser.add_option("-Z", "--zotero-bundle-only", dest="makezoterobundle",
<                       default=False,
<                       action="store_true", 
<                       help='Create a citeproce4x.js bundle with embedded e4x support suitable for use in Zotero, and exit.')
713,739c386
<     if opt.tracemonkey and opt.rhino_json:
<         print parser.print_help()
<         print "\nError: The -T and -J options cannot be used together."
<         sys.exit()
< 
<     if opt.makebundle and opt.makezoterobundle:
<         print parser.print_help()
<         print "\nError: The -B and -Z options cannot be used together."
<         sys.exit()
< 
<     if opt.makebundle:
<         bundler = Bundle()
<         bundler.deleteOldBundle()
<         bundler.createNewBundle()
<         license = ApplyLicense()
<         license.apply()
<         sys.exit()
< 
<     if opt.makezoterobundle:
<         bundler = Bundle(mode="zotero")
<         bundler.deleteOldBundle()
<         bundler.createNewBundle()
<         license = ApplyLicense()
<         license.apply()
<         sys.exit()
< 
<     if not opt.teststyles and not opt.testrun and not opt.grind and not opt.cranky and not opt.processor and not opt.bundle:
---
>     if not opt.grind and not opt.cranky:
754,774d400
<     # Validation
<     #
<     if opt.bundle and (opt.teststyles or opt.processor or opt.grind or opt.cranky or opt.testrun or len(args)):
<         print parser.print_help()
<         print "\nError: Option -r must be used alone"
<         sys.exit()
<     if opt.processor and (opt.grind or opt.cranky or opt.testrun or opt.teststyles):
<         parser.print_help()
<         print "\nError: Option -p cannot be used with options -c, -g, -s or -S.\n"
<         sys.exit()
<     elif opt.processor and len(args) and len(args) != 1:
<         parser.print_help()
<         print "\nError: Use only one argument (the test name) with the -p option.\n"
<         sys.exit()
<     elif (opt.grind or opt.cranky or opt.testrun or opt.teststyles) and len(args) and len(args) != 2 and len(args) != 1:
<         parser.print_help()
<         print "\nError: Use one or two arguments with the -c, -g, -s or -S options (group name plus"
<         print "       optionally the test name).\n"
<         sys.exit()
< 
<     #
777,786c403
<     if opt.teststyles:
<         category = "styletests"
<     else:
<         category = "std"
<     if opt.processor:
<         params = Params(opt,args,"citeproc_js",force="citeproc_js")
<     elif len(args) < 2:
<         params = Params(opt,args,category,force="std")
<     else:
<         params = Params(opt,args,category)
---
>     params = Params(opt,args)
788,800d404
<     #
<     # Will do something, so issue date stamp
<     #
<     start = datetime.now()
<     START="%s:%s:%s <--------------START" % (start.hour,start.minute,start.second)
<     print START
< 
< 
< 
<     if opt.bundle:
<         opt.grind = True
<         opt.verbose = True
<         opt.testrun = True
802,823c406,414
<         if opt.cranky or opt.grind or opt.testrun or opt.teststyles:
<             params.getSourcePaths()
<             if opt.grind or ((opt.testrun or opt.teststyles) and opt.bundle):
<                 params.clearSource()
<                 params.refreshSource(force=True)
<                 print ""
<             else:
<                 params.refreshSource()
<             if opt.cranky:
<                 params.validateSource()
<             if opt.bundle:
<                 bundle = Bundle()
<                 bundle.deleteOldBundle()
<                 bundle.createNewBundle()
<                 license = ApplyLicense()
<                 license.apply()
<             if opt.testrun or opt.teststyles:
<                 params.buildRunner()
<                 params.runTests(bundle=opt.bundle)
<         elif opt.processor:
<             params.buildRunner()
<             params.runTests()
---
>         params.getSourcePaths()
>         if opt.grind:
>             params.clearSource()
>             params.refreshSource(force=True)
>             print ""
>         else:
>             params.refreshSource()
>         if opt.cranky:
>             params.validateSource()
829c420
<     except MissingHumansFile, error:
---
>     except MissingHumansFile as error:
840,845c431
<     end = datetime.now()
<     END="%s:%s:%s <--------------END" % (end.hour,end.minute,end.second)
<     print END
< 
<     diff = end-start
<     print "Time: %s seconds" % (diff.seconds)
---
>     print "Processor tests successfully compiled"
